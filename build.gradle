/* ============================================================================
 * Build file for project 'CI-CD_EchoServerBE'
 * ============================================================================
 * This file was initial generated by EGradle
 * using 'Basic single gradle project (Java)' template
 * 
 * This is a very basic template suitable for gradle beginners and is nearly the
 * same as done by Gradle 'init' task. This generated file contains a sample 
 * Java project to get you started. In addition it will setup all necessary
 * eclipse parts also, so an out of the box import is possible.
 *
 * For more details about the java parts take a look at the Java Quickstart 
 * chapter in the Gradle user guide available at 
 * https://docs.gradle.org/current/userguide/tutorial_java_projects.html
 * ============================================================================
 */
 
plugins
{
   // Apply the java plugin to add support for Java
	id 'java'

	// Apply the eclipse plugin to add support for Eclipse
	id 'eclipse'

	// gradle-docker plugins
	id 'com.palantir.docker' version '0.21.0'
	id 'com.palantir.docker-run' version '0.21.0'

	// gradle-helm-plugin plugins
	id 'org.unbroken-dome.helm' version '0.3.0'
	id 'org.unbroken-dome.helm-releases' version '0.3.0'
	
	// gradle-git-version plugin
	id 'com.palantir.git-version' version '0.11.0'

	// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
	id 'com.google.protobuf' version '0.8.8'
	
	// Gradle Spawn Plugin
	id 'com.wiredforcode.spawn' version '0.8.2'	
}
 
// Apply the java plugin to add support for Java
//apply plugin: 'java'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// Updating the version in our release process.
def grpcVersion = '1.21.0'
def protobufVersion = '3.7.1'
def protocVersion = protobufVersion

// In this section you declare the dependencies for your production and test code
dependencies {
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.25'

    implementation "io.grpc:grpc-protobuf:${grpcVersion}"
    implementation "io.grpc:grpc-stub:${grpcVersion}"
    compileOnly "javax.annotation:javax.annotation-api:1.2"

    runtimeOnly "io.grpc:grpc-netty-shaded:${grpcVersion}"
    
    // Declare the dependency for your favourite test framework you want to use in your tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile 'junit:junit:4.12'
}

// Configure protobuf
protobuf {
	protoc { 
   	artifact = "com.google.protobuf:protoc:${protocVersion}" 
   }
	plugins {
		grpc { 
			artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" 
		}
	}
	generateProtoTasks {
		all()*.plugins { 
			grpc {} 
		}
	}
}

// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.
sourceSets {
	main {
		java {
			srcDirs 'build/generated/source/proto/main/grpc'
			srcDirs 'build/generated/source/proto/main/java'
		}
	}
}

/* ----------------------------------------------------------------------------
 *
 *  Additional parts from EGradle template for comfortable eclipse setup
 *  (necessary, because every EGradle template MUST be importable out of the box)
 * 
 * ---------------------------------------------------------------------------- */
// Apply the eclipse plugin to add support for Eclipse
//apply plugin: 'eclipse'

// To have javadocs in eclipse added - where no sources are available - we need these lines:
// see https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html
eclipse {	 
	classpath {
		downloadSources = true // default: true
		downloadJavadoc = true // default: false
	}
} 

// first define an array containing source folders to be always available - even when not existing already
def eclipseSourceFolders = [
	'src/main/java',
	'src/main/resources',
	'src/test/java',
	'src/test/resources'
];

// now create those source folders when not existing, when eclipse task is executed:
tasks.eclipse.dependsOn << {	
	for (String sourceFolder: eclipseSourceFolders) { 
		def resourceDir = new File(project.projectDir, sourceFolder)
		
		if (!resourceDir.exists() && !resourceDir.mkdirs()) {
    		logger.info("Not able to create %1",resourceDir);
    	}
	}
}

// Adding some properties
ext {
	serviceName = "demo4echo"	// For DockerHub registry
	productName = "echobe"		// e.g. apigw (one of the microservices of the admin portal)
	productRepository = "${serviceName}/${productName}"
//	productVersion = "v0.1.0-feature1"
//	productVersion = gitVersion()
	productVersion = manifestVersion()
	productInternalPort = "3333"
	productExternalPort = "30333"
	productK8ShelmChartsFolder = "k8s/helm/charts"
}

// Create an uber jar
jar {
	manifest	{
   	attributes "Main-Class": "com.efrat.example.devops.echoServerBEApp.EchoServerBEApp"
	}

	from	{
		configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
	}
}

// Make prints in tests visible
test {
	testLogging {
		outputs.upToDateWhen {false}
		showStandardStreams = true
		systemProperties = System.properties
	}
}

// Special test task meant to run manually outside the cluster (development mode) and since the service isn't published outside
// the cluster, we'll need kubectl port forwarding
task testViaPortForwarding(dependsOn: ['startKubectlPortForwarding','test','stopKubectlPortForwarding'])

//
// Deal with kubectl port-forward blocking command
//

task startKubectlPortForwarding(type: SpawnProcessTask) {
	command "kubectl port-forward services/${productName}-service ${productInternalPort}:${productInternalPort}"
	ready 'Forwarding from'
//	pidLockFileName '.other.pid.lock'	
}

task stopKubectlPortForwarding(type: KillProcessTask) {
//	pidLockFileName '.other.pid.lock'	
}

//
// docker
//

docker {
	name "${productName}:${productVersion}"
	tag "privateRegistry", "${productRepository}:${productVersion}"	// For DockerHub registry
	buildArgs([JAR_PRODUCT_NAME:"${project.name}",JAR_PRODUCT_VERSION:"${productVersion}",PRODUCT_INTERNAL_PORT:"${productInternalPort}"])
	files jar.outputs
	copySpec.into("build/libs")
//	pull true
//	noCache true
}

// Give an alias to docker task
task dockerBuild(dependsOn: ['jar','docker'])

dockerRun {
	name "${productName}"
	image "${productName}:${productVersion}"
	ports "${productExternalPort}:${productInternalPort}"
	env 'INTERNAL_PORT_ENV_VAR':"${productInternalPort}"
	daemonize true
	clean true
}

// Main task used from docker plugins
task dockerBuildAndPublish(dependsOn: 'dockerPushPrivateRegistry')

// Give an alias to dockerRun task
task dockerStart(dependsOn: ['dockerBuild','dockerRun'])

//
// helm
//

helm {
	home = file("$System.env.HOME/.helm")
	debug = true

	filtering {
		// These values will be resolvable in all charts' YAML files (e.g. imageTag => ${productVersion})
		values.put 'imageTag',"${productVersion}"
		values.put 'imageRepository',"${productRepository}"
		values.put 'servicePort',"${productInternalPort}"
		values.put 'serviceTargetPort',"${productInternalPort}"
		values.put 'serviceNodePort',"${productExternalPort}"
	}

	charts {
		echobe {
			chartVersion = "${productVersion}"
			sourceDir = file("${productK8ShelmChartsFolder}/${productName}")
		}
	}

	lint {
		// enable/disable linting by default
		enabled = true
		// treat linter warnings as errors (failing the build)
		strict = true
	}

	releases {
		echobe {
			from charts.echobe
			purge = true
			
			// If true, perform a dry run 
//			dryRun = true
			
			// pass values (like --set on the command line)
//			values = ['image.tag':"${productVersion}"]

			// If true, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are in a ready state before marking the release as successful
//			wait = true
		}
	}
}

task helmUpdate(dependsOn: 'helmInstall')
task helmUninstall(dependsOn: 'helmDelete')

task helmTest(type:Exec) {
	executable "helm"
	args "test","${productName}"
}

task helmTestAndClean(type:Exec) {
	executable "helm"
	args "test","${productName}","--cleanup"
}

// Notes:
// 1. helmPackge and helmInstall tasks are used as is
// 2. helmInstall and helmUninstall (helmDelete) can be used with "-Phelm.dryRun"

//
// The function builds a proper version name
//
def manifestVersion() {
	def details = versionDetails()

	// An alternative (can also be "v0.1.0-demo.${details.branchName}")
	return "v0.1.0-${details.branchName}"
}

description = 'The Echo Backend demo product'
version = "${productVersion}"
